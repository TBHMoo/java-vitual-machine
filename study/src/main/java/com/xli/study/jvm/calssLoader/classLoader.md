# 虚拟机的类加载机制

<!-- TOC -->

- [虚拟机的类加载机制](#虚拟机的类加载机制)
    - [类加载的时机](#类加载的时机)
        - [类的显式加载和隐式加载](#类的显式加载和隐式加载)
    - [类加载的过程](#类加载的过程)
        - [类的生命周期](#类的生命周期)
        - [加载](#加载)
            - [加载的 3 个阶段](#加载的-3-个阶段)
            - [分类](#分类)
        - [验证](#验证)
        - [准备](#准备)
        - [解析](#解析)
        - [初始化](#初始化)
    - [类加载器](#类加载器)
        - [如何判断两个类 “相等”](#如何判断两个类-相等)
        - [类加载器的分类](#类加载器的分类)
        - [双亲委派模型](#双亲委派模型)

<!-- /TOC -->
## 类加载的时机

[深入探讨 Java 类加载器](https://developer.ibm.com/zh/articles/j-lo-classloader)

JVM 会在第一次主动引用类的时候，加载该类，被动引用时不会加载该类。也就是说，JVM并不是一开始就把一个程序的所有类都加载到内存中，而是到使用时才把他加载进来，而且只加载一次。那么什么是主动引用，什么是被动引用？

- **主动引用**
    - 遇到 new 、getstatic,putstatic,invokestatic 字节码指令，例如：
        - 使用 new 实例化对象
        - 读取或设置一个类的 static变量（被 final 修饰的除外）
        - 调用类的静态方法
    - 对类进行反射调用
    - 初始化一个类时，父类还没有初始化（需先初始化父类）：
        - 这点类与接口具有不同的表现，初始化接口时，不要求其父接口完成初始化，只有真正使用父接口时才初始化，如引用父接口中定义的常量
    - 虚拟机启动，先初始化包含main()方法主类   
- **被动引用**
    - 通过子类引用父类静态字段，不会导致子类初始化
    - `Array[] arr = new Array[10];`  不会触发Array类初始化
    - `static final VAR` 在编译阶段会放入类的常量池，通过`ClassName.VAR`引用不会触发ClassName初始化
    
也就是说，只有主动引用列出的情况，一个类才会被加载到内存中，也就是说类的加载时Lazy-load的，不到必要时候不会提前加载。 提前加载但是不使用，会浪费内存

## 类的显示加载和隐式加载
- **显示加载**
    - 调用反射 `ClassLoader#loadClass(className)` 或 `Class.forName(className)`
    - 两种显示加载.class文件的区别
        - `Class.forName(className)` 加载class的同时会初始化静态域
        - `ClassLoader#loadClass(className)` 不会初始化静态域
        - `Class.forName(className)` 借助当前调用者的class 的ClassLoader 完成class加载
- **隐式加载**
    - new 类对象
    - 使用类的静态域
    - 创建子类对象
    - 使用子类的静态域
    - 其他隐式加载，在JVM启动时
        - BootStarpLoader 加载JVM自身运行所需class  ,在<JAVA_HOME>/lib下
        - ExtentionLoader 加载在<JAVA_HOME>/lib/ext下 class
        - ApplicationLoader 加载main()函数所在的Class,以及<ClassPath> 路径下的class
        
        
## 类加载的过程
### 类的生命周期
```
加载 --> 验证 --> 准备 --> 解析 --> 初始化 --> 使用 ---> 卸载
        |<-------- 链接 ----->|
|<----------------类加载---------------->|
```
类的生命周期一共7个阶段，前5个阶段比较重要成为【类加载】，第2-4阶段称为链接，加载和链接的3个阶段开始顺序是固定的，但是执行过程中是可以交叉执行。接下来对5个阶段进行一一讲解

### 加载
#### 加载的三个阶段
- 通过类的全限定名来获取定义此类的二进制字节流 (将.class 文件读进内存)
- 将字节流的静态存储结构转化为运行时数据结构
- 在内存中生成该类的 Class 对象
    - Hotspot 虚拟机将这个对象放在方法区，而不是堆区
### 验证 ClassFormatFile
- **目的** ：确保.class 文件中的字节流信息符合虚拟机要求
- **四个验证过程：**
    -文件格式验证： 是否符合.class文件格式规范，验证文件开头4个字节是不是 “魔数” `OxCAFEBABE`
    -元数据验证：保证字节码描述信息符合 java 规范（语义分析）
    -字节码验证：程序语义，逻辑是否正确（通过数据流，控制流分析）
    -符号引用验证：对类自身以外的信息（常量池中的符号引用）进行匹配性校验
### 准备
- **描述：** 为static 变量在方法区分配内存
- static 变量准备后的初始值：
    - `public static int i = 123;` 
        - 准备后为0，i的赋值指令 putstatic 会被放在 `<clinit>()` 方法中，`<clinit>()`会在初始化时执行，也就是说，`i` 变量只有在初始化后才等于123
        
    - `public static final int i = 123;` 
        - 准备后为123，因为被 `final ` 修饰后 `i`就不能再修改了
### 解析
- **描述：** 将常量池中的“符号引用”替换为“直接引用”
    - 在此之前，常量池中的引用不一定都存在，解析过后，可以保证常量池中的引用在内存中一定存在
    - 什么是“符号引用” 和 “符号引用”？
        - 符号引用： 以一组符号描述所引用的对象 (如对象的全类名)，引用的目标不一定存在内存中  
            - 主要 CONSTANT_Class_info,CONSTANT_Fieldref_info,CONSTANT_methodref_info, CONSTANT_interfaceref_info
        - 直接引用： 直接指向被引用目标在内存中的指针等，引用目标一定存在内存中
### 初始化
- **描述:** 执行类构造器 `<clinit>()` 方法的过程
- **`<clinit>()`方法**
    - 包含的内容：
        - 所有 static 的赋值操作
        - static 块中的语句
    - `<clinit>()`方法中的语句顺序：
        - 基本按照语句在源文件中出现的顺序排列
        - 静态语句块只能访问定义在它前面的变量，定义在它后面的变量，可以赋值，不可访问
    - 与`<init>()` 的不同：
        - 不需要显示调用父类的`<clinit>()` 方法
        - 虚拟机保证在子类的`<clinit>()` 方法执行前，父类的`<clinit>()`方法一定执行完毕
            - 也就是说，父类的static块和 static字段的赋值操作先于子类
    - 接口与类的不同：
        - 执行子接口的`<clinit>()`方法前，不需要先执行父接口的 `<clinit>()` 方法，（除非用到了父接口中定义的 public static final变量）
    - 执行过程加锁：
        - 同一时刻，只能有一个线程在执行`<clinit>()`方法，因为虚拟机要保证在同一个类加载旗下，一个类只被加载一次
    - 非必要性：
        - 一个类如果没有任何static内容就不需要执行`<clinit>()`方法
*注：初始化时，才真正实心类中定义的java代码*

## 类加载器
### 如何判断两个类“相等”
- **“相等的要求”**
    - 同一个 .class 文件
    - 被同一个虚拟机加载
    - 被同一个类加载器加载
- **判断“相等”的方法**
    - `instanceof` 关键字
    - Class对象中的方法：
        - `equals()`
        - `isInstance()`
        - `asAssignableFrom`
### 类加载器的分类
- **启动类加载器(BootStrap)**
    -<JAVA_HOME>/lib
    - -Xbootclasspath 参数指定路径
- **扩展类加载器(Extension)**
    -<JAVA_HOME>/lib/ext
    - java.ext.dirs 系统变量指定的路径
- **应用程序类加载器(Application)**
    - -classpath 参数
    - main()方法所在Class
- **自定义类加载器(继承 java.lang.ClassLoader)**
    - -classpath 参数
    - main()方法所在Class
 
### 双亲委派模型
- **工作过程**
    - 当前类加载器收到类加载的请求时，先不自己尝试加载，而是将请求委派给父类加载器
        - 因此，所有类加载的请求，都会先被启动类加载器执行(BootStrap)
    - 只有当父类加载器加载失败时，当前加载器才会尝试自己加载负责的区域
- **实现**
    - 检查该类是否已被加载
    - 将类加载请求委派给父类
        - 如果父类加载器为 null( 也就是说 已经是BootStrap) ,默认使用启动类加载器
        - `parent.loadClass(name,false)`
    - 当父类加载失败时
        - catch ClassNotFoundException 但不做任何处理
        - 调用自己的 findClass() 去加载
            - 我们在实现自己的类加载器时只需要 `extends ClassLoader`,然后再重写 `findClass()`方法，而不是`loadClass()`方法，这样就不用重写`loadClass()` 中的双亲委派机制了
- **优点**
    - 自己写的类库同名类不会覆盖类库的类
- **扩展**
    -IDE 热部署，OSGI,Spring 代理，不是用的双亲委派机制