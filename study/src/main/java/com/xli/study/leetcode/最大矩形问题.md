# 最大矩形问题
```html
这类问题都是通过枚举其中一个维度，将问题划归为一维问题来求解
```
- [84.柱状图中的最大矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/submissions/)
- [85.最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)
    - 将问题降维成,w*h 求h个柱状图问题
    - 求柱状图过程
        - w*h ,可以枚举w 或 h
            - w 由两个边界坐标确定
            - h 由高度确认（下标索引） 只用枚举一个变量
        - 暴力过程，遍历高，向左右扩展到最边界，第一个大于等于当前高，且下一个柱子低于当前高索引
            - 暴力O(n^2) 超时 ,尝试模拟O(n)思路
        - 2 1 5 6 2 3 脑中模拟遍历过程
            - 遍历过程中
            - 遍历2时，无法确认任何矩形面积 2
            - 遍历1时，2确定的矩形面积确定下来，此时 2>1 ,2向右扩展  2 -> 1
            - 便利5时，无法确认任何矩形面积，1 5
            - 便历6时，无法确定任何矩形面积， 1 5 6
            - 便利2时，6>2 可以确定6高度的矩形面积，宽为 2到5之间，1的宽度 1 5 6 -> 1 5
                - 此时 5>2 依然可以确定5 高度的矩形面积，宽为2到1之间，1<5 ,5>2 ,长度为2的宽度  15 -> 1
            - 便历到3时，无法确定任何矩形面积 1 2 3
            - 便利结束，剩下 1 2 3 ，此时3是最后的柱子，可以利用哨兵思想，在最后追加一个高度为0的柱子，那么
                - 此时 1 2 3 ，下一个哨兵柱子高度为0 那么3高度的柱子矩形面积可以确定 宽为 哨兵柱子下标 到 3>2 2的下标
                - 此时 1 2 ，下一个哨兵柱子高度为0，那么2高度的柱子矩形面积可以确定，宽为 哨兵主子下标 到 2>1 1的下标之间
                - 此时 1，下一个哨兵柱子高度为0，1>0,那么1高度的柱子矩形面积可以确定，宽为哨兵柱子下标 到 1的左端没有柱子，一样的添加一个左哨兵柱子高度为0，宽的左标就是左哨兵下标
              
```java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        if(matrix == null || matrix.length ==0) return 0;
        int[] line = new int[matrix[0].length];
        int ret = 0;
        int h = matrix.length;
        int w = matrix[0].length;
        for(int i=0;i<h;i++){
            for(int j=0;j<w;j++){
                if(matrix[i][j] == '0'){
                    line[j] = 0;
                }else {
                    line[j] += matrix[i][j] - '0';
                }
            }
            ret = Math.max(ret,largestRectangleArea(line));
        }
        return ret;
    }

    /** 2 1 5 6 2 3  在脑子里遍历过一边这个例子的柱状图，确定的面积顺序**/
    public int largestRectangleArea(int[] heights){
        int area = 0;
        int len = heights.length;
        int[] newheights = new int[len+2];
        for(int i=0;i<len;i++){
            newheights[i+1] = heights[i];
        }
        heights = newheights;
        len+=2;
        Deque<Integer> stack = new ArrayDeque<>();
        stack.addLast(0);
        for(int i=1;i<len;i++){
            while(heights[stack.peekLast()] > heights[i]){
                int high = heights[stack.removeLast()];
                int with = i - stack.peekLast() - 1;
                area = Math.max(area,high*with);
            }
            stack.addLast(i);
        }
        return area;
    }
}
```
- [1727.重排列后的最大子矩阵](https://leetcode-cn.com/problems/largest-submatrix-with-rearrangements/)
    - 如果不允许重排，那么问题和 [85.最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/) 一样了
    - 思考暴力解法？如何实现重排列？ 
        - 无法暴力 m*n  10^5数量级，暴力重排1-10^5 阶乘
    - 示例2 ，是求柱状图情况， 
        - 降维成柱状图 
    - 示例3，是提示只能整列重排 
        - 按列统计 ，从上往下累加遇0清0，重新计算
        - w*h ，统计后，可以拿到未重排的h个柱状图，发现重排策略按高度排序后进行处理，这是面积最大的最优情况
    - 示例4 是空矩阵，特判情况 
```java
/**
    - 如果不允许重排，那么问题和 [85.最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/) 一样了
    - 思考暴力解法？如何实现重排列？ 
        - 无法暴力 m*n  10^5数量级，暴力重排1-10^5 阶乘
    - 示例2 ，是求柱状图情况， 
        - 降维成柱状图 
    - 示例3，是提示只能整列重排 
        - 按列统计 ，从上往下累加遇0清0，重新计算
        - w*h ，统计后，可以拿到未重排的h个柱状图，发现重排策略按高度排序后进行处理，这是面积最大的最优情况
            - 柱状图排序后，最大面积可以直接通过h*w 得到 即 2 1 5 6 2 3 -> 1 2 2 3 5 6 的柱状图最大面积
    - 示例4 是空矩阵，特判情况 
**/
class Solution {
    public int largestSubmatrix(int[][] matrix) {
        if(matrix == null || matrix.length == 0) return 0;
        // 列统计，遇0重新开始统计
        // 枚举行，行排序后计算最大矩形面积
        int ret = 0;
        int h = matrix.length;
        int w = matrix[0].length;
        int[] line = new int[matrix[0].length];
        for(int i=0;i<h;i++){
            for(int j=0;j<w;j++){
                if(matrix[i][j] == 1 && i>0){
                    matrix[i][j] += matrix[i-1][j];
                }
                line[j] = matrix[i][j];
            }
            // line = matrix[i];
            // for(int k=0;k<line.length;k++){
            //     System.out.print(line[k]);
            // }
            // System.out.println();
            Arrays.sort(line);
            
//            ret = Math.max(ret,largestRectengleArea(line));
            for(int j=0;j<w;j++){
                ret = Math.max(ret,line[j]*(w-j));
            }
        }
        return ret;
    }

    /** 最大矩形面积 2 1 5 6 2 3 过程
    [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1],
     [0,1,1,0,1,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,1,1]]
    **/
    public int largestRectengleArea(int[] heights){
        int area = 0;
        int[] temp = new int[heights.length+2];//前后哨兵柱状图
        for(int i=0;i<heights.length;i++){
            temp[i+1] = heights[i];
        }
        Deque<Integer> stack = new ArrayDeque<>();
        stack.addLast(0);
        int len = temp.length;
        heights = temp;
        for(int i=1;i<len;i++){
            while(heights[stack.peekLast()] > heights[i]){
                int high = heights[stack.removeLast()];
                int with = i - stack.peekLast() -1;
                area = Math.max(area, high*with);
            }
            stack.addLast(i);
        }
        return area;
    }
}



class Solution2 {
    public int largestSubmatrix(int[][] matrix) {
        if(matrix == null || matrix.length == 0) return 0;
        // 列统计，遇0重新开始统计
        // 枚举行，行排序后计算最大矩形面积
        int ret = 0;
        int h = matrix.length;
        int w = matrix[0].length;
        int[] line = new int[matrix[0].length];
        for(int i=0;i<h;i++){
            for(int j=0;j<w;j++){
                if(matrix[i][j] == 1 && i>0){
                    matrix[i][j] += matrix[i-1][j];
                }
                line[j] = matrix[i][j];
            }
            Arrays.sort(line);
            for(int j=0;j<w;j++){
                /** 柱状图排序后，最大面积可以直接通过h*w 得到 即 2 1 5 6 2 3 -> 1 2 2 3 5 6 的柱状图最大面积**/
                ret = Math.max(ret,line[j]*(w-j)); 

            }
        }
        return ret;
    }
}


```

- [42.接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

- 接雨水
    - 雨水柱状图 - 原始柱状图 = 雨水量
    - 面积的 w*h , 枚举h ,向两边寻找最高点，取两个最高点的那个小点，hleft - h 即 当前柱状图雨水后的雨水量
    - 先暴力一发，看看
    - 过了...
  
    - O(n^2), 尝试 O(n) 思路，每个柱子，每次找左最高点，和右最高点,需要遍历一遍，能否提前记录下来
        - 从左往右遍历，只能知道当前最高点，如果当前最高点，
             - 高于下一个要遍历的柱子，那么，下一个柱子的左最高点为当前最高点，
             - 等于下一个要遍历的柱子，那么，下一个柱子的左最高点为当前最高点， 不影响雨水量
             - 低于下一个要遍历的柱子，那么，下一个柱子的左最高点为自身高度，并替换当前最高点
        - 从右往左遍历可以得到每个柱子的右最高点
    - 时间O(n) 空间(n)
    - 遍历了两次，可否遍历一遍O(n)？
    
         - 模拟 遍历过程确认柱子的雨水量
         - ![雨水图](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)
         - [0,1,0,2,1,0,1,3,2,1, 2, 1]
         - h[0,1,2,3,4,5,6,7,8,9,10,11]
            - 遍历到h[0] 一根柱子，无法确定雨水
            - 遍历到h[1] , 当前待确定雨水柱子 0,1 -> 1 
            - 遍历到h[2] , 当前待确定雨水柱子 0,1,0
            - 遍历到h[3] , 当前待确定雨水柱子 0,1,0,如果h[3]加入柱子，形成 0,1,0,2 
               - 那么 h[2],0 这根柱子的雨水量确定了，是 2,和 1 之间的小值， 当前待确定雨水柱子 0,1,2
               - +1
               - 思考后 发现0，1 这两个柱子，是容纳不了雨水的，所以待确认柱子变成 2
            - 遍历到h[4] , 当前待确定雨水柱子 0,1,2,如果h[4]加入柱子，形成 0,1,2,1  
            - 遍历到h[5] , 当前待确定雨水柱子 0,1,2,1,如果h[5]加入柱子，形成 0,1,2,1,0  
            - 遍历到h[6] , 当前待确定雨水柱子 0,1,2,1,0,如果h[6]加入柱子，形成 0,1,2,1,0,1
               - 那么0，这根柱子，可以增加雨水 到1，  当前待确定雨水柱子 0,1,2,1,1,1，因为后面的柱子可能会更高        
               - +1
            - 遍历到h[7], 当前待确定雨水柱子 0,1,2,1,1,1,如果h[7]加入柱子，形成0,1,2,1,1,1，3，
               - 那么1，可以增加到雨水 2
               - 那么1，可以增加到雨水 2
               - 那么1，可以增加到雨水 2
               - +3
               - 此时 待确定雨水柱子 0,1,2,3
               - 思考后，此时，待确认雨水柱子 变成 3,（其实3也一定确认最高就是3，但是后续的柱子，需要一个左最高柱子）
            - 遍历到h[8], 当前待确定雨水柱子 0,1,2,3，如果加入h[8] ,形成0,1,2,3,2
            - 遍历到h[9], 当前待确定雨水柱子 0,1,2,3,2 如果加入h[9] ,形成0,1,2,3,2,1
            - 遍历到h[10], 当前待确定雨水柱子 0,1,2,3,2,1 如果加入h[10] ,形成0,1,2,3,2,1,2,
               - 此时 1<2 ，那么1 可以增加到2，形成 0,1,2,3,2,2,2
               - +1 
            - 遍历到h[11], 当前待确定雨水柱子 0,1,2,3,2,2,2 如果加入h[11] ,形成0,1,2,3,2,2,2,1
            - 结果为6
         
         - 从确定雨水量的例子可以看出
            - h[i]<=h[i+1] 时，h[i]可以确认容纳一部分雨水，
                - 如果h[i+1] >= (h[i]的左边待确认柱子最大高度)， 那么h[i] 最后能容纳的雨水量也确定了，                - 如果h[i+1] < (h[i]的左边待确认柱子最大高度), 那么h[i] 能确定增加容纳雨水量 h[i+1] - h[i]
    
         - 需要记录的信息是 左边待确认雨水的柱子，是一个非严格递减的阶梯，这个阶梯可以用栈维护
            - 整个过程可以描述成，一个从高到低的阶梯,遍历一个从低到高的阶梯，确认雨水量，从高到低的阶梯，可以用栈维护，阶梯可以相等，非严格递减
            - 左右两端加个哨兵柱子， 高度为0
```java
/**
* - 接雨水
      - 雨水柱状图 - 原始柱状图 = 雨水量
      - 面积的 w*h , 枚举h ,向两边寻找最高点，取两个最高点的那个小点，hleft - h 即 当前柱状图雨水后的雨水量
      - 先暴力一发，看看
      - 过了...
*/
class Solution {
    public int trap(int[] height) {
        int len = height.length;
        int ret = 0;
        for(int i=0;i<len;i++){
            int h = height[i];
            int left = i;
            int hleft = h;
            while(left >= 0){
                hleft = Math.max(hleft,height[left]);
                left--;
            }
            int right = i;
            int hright = h;
            while(right < len){
                hright = Math.max(hright,height[right]);
                right++;
            }
            int highv2 = Math.min(hleft,hright);
            // System.out.println(height[i] + " --------->" + highv2 + "      hleft = " + hleft + " hright = " + hright);
            ret+= highv2-height[i];
        }
        // System.out.println("============================");
        return ret;
    }
}

/**
* - O(n^2), 尝试 O(n) 思路，每个柱子，每次找左最高点，和右最高点,需要遍历一遍，能否提前记录下来
      - 从左往右遍历，只能知道当前最高点，如果当前最高点，
           - 高于下一个要遍历的柱子，那么，下一个柱子的左最高点为当前最高点，
           - 等于下一个要遍历的柱子，那么，下一个柱子的左最高点为当前最高点， 不影响雨水量
           - 低于下一个要遍历的柱子，那么，下一个柱子的左最高点为自身高度，并替换当前最高点
      
      - 从右往左遍历可以得到每个柱子的右最高点
  - 时间O(n*2) 空间(n*2)
  - 遍历了两次，可否遍历一遍 ，单调栈处理？
     - 模拟 遍历过程确认柱子的雨水量
        - 
*/
class Solution {
    public int trap(int[] height) {
        if(height == null || height.length ==0) return 0;
        int len = height.length;
        int[] hleft = new int[len];
        int[] hright = new int[len]; 
        int ret = 0;
        int maxlh =height[0];
        for(int i=0;i<len;i++){
            if(height[i] >= maxlh){
                maxlh = height[i];
            }
            hleft[i] = maxlh;
        }
        int maxrh = height[len-1];
        for(int j=len-1;j>=0;j--){
            if(height[j] >= maxrh){
                maxrh = height[j];
            }
            hright[j] = maxrh;
            ret += Math.min(hleft[j],hright[j]) - height[j];
        }
        return ret;
    }
}


/**
* - 遍历了两次，可否遍历一遍O(n)？
      
           - 模拟 遍历过程确认柱子的雨水量
           - ![雨水图](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)
           - [0,1,0,2,1,0,1,3,2,1, 2, 1]
           - h[0,1,2,3,4,5,6,7,8,9,10,11]
              - 遍历到h[0] 一根柱子，无法确定雨水
              - 遍历到h[1] , 当前待确定雨水柱子 0,1 -> 1 
              - 遍历到h[2] , 当前待确定雨水柱子 0,1,0
              - 遍历到h[3] , 当前待确定雨水柱子 0,1,0,如果h[3]加入柱子，形成 0,1,0,2 
                 - 那么 h[2],0 这根柱子的雨水量确定了，是 2,和 1 之间的小值， 当前待确定雨水柱子 0,1,2
                 - +1
                 - 思考后 发现0，1 这两个柱子，是容纳不了雨水的，所以待确认柱子变成 2
              - 遍历到h[4] , 当前待确定雨水柱子 0,1,2,如果h[4]加入柱子，形成 0,1,2,1  
              - 遍历到h[5] , 当前待确定雨水柱子 0,1,2,1,如果h[5]加入柱子，形成 0,1,2,1,0  
              - 遍历到h[6] , 当前待确定雨水柱子 0,1,2,1,0,如果h[6]加入柱子，形成 0,1,2,1,0,1
                 - 那么0，这根柱子，可以增加雨水 到1，  当前待确定雨水柱子 0,1,2,1,1,1，因为后面的柱子可能会更高        
                 - +1
              - 遍历到h[7], 当前待确定雨水柱子 0,1,2,1,1,1,如果h[7]加入柱子，形成0,1,2,1,1,1，3，
                 - 那么1，可以增加到雨水 2
                 - 那么1，可以增加到雨水 2
                 - 那么1，可以增加到雨水 2
                 - +3
                 - 此时 待确定雨水柱子 0,1,2,3
                 - 思考后，此时，待确认雨水柱子 变成 3,（其实3也一定确认最高就是3，但是后续的柱子，需要一个左最高柱子）
              - 遍历到h[8], 当前待确定雨水柱子 0,1,2,3，如果加入h[8] ,形成0,1,2,3,2
              - 遍历到h[9], 当前待确定雨水柱子 0,1,2,3,2 如果加入h[9] ,形成0,1,2,3,2,1
              - 遍历到h[10], 当前待确定雨水柱子 0,1,2,3,2,1 如果加入h[10] ,形成0,1,2,3,2,1,2,
                 - 此时 1<2 ，那么1 可以增加到2，形成 0,1,2,3,2,2,2
                 - +1 
              - 遍历到h[11], 当前待确定雨水柱子 0,1,2,3,2,2,2 如果加入h[11] ,形成0,1,2,3,2,2,2,1
              - 结果为6
           
           - 从确定雨水量的例子可以看出
              - h[i]<=h[i+1] 时，h[i]可以确认容纳一部分雨水，
                  - 如果h[i+1] >= (h[i]的左边待确认柱子最大高度)， 那么h[i] 最后能容纳的雨水量也确定了，                - 如果h[i+1] < (h[i]的左边待确认柱子最大高度), 那么h[i] 能确定增加容纳雨水量 h[i+1] - h[i]
      
           - 需要记录的信息是 左边待确认雨水的柱子，是一个非严格递减的阶梯，这个阶梯可以用栈维护
              - 整个过程可以描述成，一个从高到低的阶梯,遍历一个从低到高的阶梯，确认雨水量，从高到低的阶梯，可以用栈维护，阶梯可以相等，非严格递减
              - 左右两端加个哨兵柱子， 高度为0
*/
class Solution {
    public int trap(int[] height) {
        if(height == null || height.length ==0) return 0;
        int len = height.length;
        int[] temp = new int[len+2];
        for(int i=0;i<len;i++){
            temp[i+1] = height[i];
        }
        len +=2;
        height = temp;
        Deque<Integer> stack = new ArrayDeque<>();
        Deque<Integer> tempStack = new ArrayDeque<>();
        stack.addLast(0);
        int ret = 0;
        for(int i=1;i<len;i++){
            while(!stack.isEmpty() && stack.peekLast() < height[i]){
                // height[i] 高于左阶梯最高点，也就是栈底, 栈清空,新的阶梯出现
                // height[i] 低于左阶梯最高点，也就是栈底,将低于 height[i]的阶梯，容量上升再放入阶梯
                if(height[i] > stack.peekFirst() ){
                    while(!stack.isEmpty()){
                        int l = stack.peekFirst();
                        int r = stack.peekLast();
                        ret += l-r;
                        stack.removeLast();
                    }
                }
                if(!stack.isEmpty() && height[i] <= stack.peekFirst()){
                    while(!stack.isEmpty() && height[i] > stack.peekLast()){
                        int r = stack.removeLast();
                        ret += height[i] - r;
                        tempStack.addLast(height[i]);
                    }
                    while(!tempStack.isEmpty()){
                        stack.addLast(tempStack.removeLast());
                    }
                }
            }
            stack.addLast(height[i]);
        }
        return ret;
    }
}

/**
*            - 需要记录的信息是 左边待确认雨水的柱子，是一个非严格递减的阶梯，这个阶梯可以用栈维护
                - 整个过程可以描述成，一个从高到低的阶梯,遍历一个从低到高的阶梯，确认雨水量，从高到低的阶梯，可以用栈维护，阶梯可以相等，非严格递减
                - 左右两端加个哨兵柱子， 高度为0
                - 右边来一个阶梯，都满上，面积可以用乘法计算
*/
class Solution {
    public int trap(int[] height) {
        if(height == null || height.length ==0) return 0;
        int len = height.length;
        int[] temp = new int[len+2];
        for(int i=0;i<len;i++){
            temp[i+1] = height[i];
        }
        len +=2;
        height = temp;
        Deque<Integer> stack = new ArrayDeque<>();
        stack.addLast(0);
        int ret = 0;
        for(int i=1;i<len;i++){
            while(!stack.isEmpty() && height[stack.peekLast()] < height[i]){
                int curtop = stack.removeLast();
                if(stack.isEmpty())break;
                int l = stack.peekLast();
                int r = i;
                int h = Math.min(height[r],height[l])-height[curtop];
                int w = r-l-1;
                ret += w*h;
            }
            stack.addLast(i);
        }
        return ret;
    }
}


```

- [407.接雨水2](https://leetcode-cn.com/problems/trapping-rain-water-ii/)

