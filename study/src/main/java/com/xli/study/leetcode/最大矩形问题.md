# 最大矩形问题
```html
这类问题都是通过枚举其中一个维度，将问题划归为一维问题来求解
```
- [84.柱状图中的最大矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/submissions/)
- [85.最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)
    - 将问题降维成,w*h 求h个柱状图问题
    - 求柱状图过程
        - w*h ,可以枚举w 或 h
            - w 由两个边界坐标确定
            - h 由高度确认（下标索引） 只用枚举一个变量
        - 暴力过程，遍历高，向左右扩展到最边界，第一个大于等于当前高，且下一个柱子低于当前高索引
            - 暴力O(n^2) 超时 ,尝试模拟O(n)思路
        - 2 1 5 6 2 3 脑中模拟遍历过程
            - 遍历过程中
            - 遍历2时，无法确认任何矩形面积 2
            - 遍历1时，2确定的矩形面积确定下来，此时 2>1 ,2向右扩展  2 -> 1
            - 便利5时，无法确认任何矩形面积，1 5
            - 便历6时，无法确定任何矩形面积， 1 5 6
            - 便利2时，6>2 可以确定6高度的矩形面积，宽为 2到5之间，1的宽度 1 5 6 -> 1 5
                - 此时 5>2 依然可以确定5 高度的矩形面积，宽为2到1之间，1<5 ,5>2 ,长度为2的宽度  15 -> 1
            - 便历到3时，无法确定任何矩形面积 1 2 3
            - 便利结束，剩下 1 2 3 ，此时3是最后的柱子，可以利用哨兵思想，在最后追加一个高度为0的柱子，那么
                - 此时 1 2 3 ，下一个哨兵柱子高度为0 那么3高度的柱子矩形面积可以确定 宽为 哨兵柱子下标 到 3>2 2的下标
                - 此时 1 2 ，下一个哨兵柱子高度为0，那么2高度的柱子矩形面积可以确定，宽为 哨兵主子下标 到 2>1 1的下标之间
                - 此时 1，下一个哨兵柱子高度为0，1>0,那么1高度的柱子矩形面积可以确定，宽为哨兵柱子下标 到 1的左端没有柱子，一样的添加一个左哨兵柱子高度为0，宽的左标就是左哨兵下标
              
```java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        if(matrix == null || matrix.length ==0) return 0;
        int[] line = new int[matrix[0].length];
        int ret = 0;
        int h = matrix.length;
        int w = matrix[0].length;
        for(int i=0;i<h;i++){
            for(int j=0;j<w;j++){
                if(matrix[i][j] == '0'){
                    line[j] = 0;
                }else {
                    line[j] += matrix[i][j] - '0';
                }
            }
            ret = Math.max(ret,largestRectangleArea(line));
        }
        return ret;
    }

    /** 2 1 5 6 2 3  在脑子里遍历过一边这个例子的柱状图，确定的面积顺序**/
    public int largestRectangleArea(int[] heights){
        int area = 0;
        int len = heights.length;
        int[] newheights = new int[len+2];
        for(int i=0;i<len;i++){
            newheights[i+1] = heights[i];
        }
        heights = newheights;
        len+=2;
        Deque<Integer> stack = new ArrayDeque<>();
        stack.addLast(0);
        for(int i=1;i<len;i++){
            while(heights[stack.peekLast()] > heights[i]){
                int high = heights[stack.removeLast()];
                int with = i - stack.peekLast() - 1;
                area = Math.max(area,high*with);
            }
            stack.addLast(i);
        }
        return area;
    }
}
```
- [1727.重排列后的最大子矩阵](https://leetcode-cn.com/problems/largest-submatrix-with-rearrangements/)
    - 如果不允许重排，那么问题和 [85.最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/) 一样了
    - 思考暴力解法？如何实现重排列？ 
        - 无法暴力 m*n  10^5数量级，暴力重排1-10^5 阶乘
    - 示例2 ，是求柱状图情况， 
        - 降维成柱状图 
    - 示例3，是提示只能整列重排 
        - 按列统计 ，从上往下累加遇0清0，重新计算
        - w*h ，统计后，可以拿到未重排的h个柱状图，发现重排策略按高度排序后进行处理，这是面积最大的最优情况
    - 示例4 是空矩阵，特判情况 
```java
/**
    - 如果不允许重排，那么问题和 [85.最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/) 一样了
    - 思考暴力解法？如何实现重排列？ 
        - 无法暴力 m*n  10^5数量级，暴力重排1-10^5 阶乘
    - 示例2 ，是求柱状图情况， 
        - 降维成柱状图 
    - 示例3，是提示只能整列重排 
        - 按列统计 ，从上往下累加遇0清0，重新计算
        - w*h ，统计后，可以拿到未重排的h个柱状图，发现重排策略按高度排序后进行处理，这是面积最大的最优情况
            - 柱状图排序后，最大面积可以直接通过h*w 得到 即 2 1 5 6 2 3 -> 1 2 2 3 5 6 的柱状图最大面积
    - 示例4 是空矩阵，特判情况 
**/
class Solution {
    public int largestSubmatrix(int[][] matrix) {
        if(matrix == null || matrix.length == 0) return 0;
        // 列统计，遇0重新开始统计
        // 枚举行，行排序后计算最大矩形面积
        int ret = 0;
        int h = matrix.length;
        int w = matrix[0].length;
        int[] line = new int[matrix[0].length];
        for(int i=0;i<h;i++){
            for(int j=0;j<w;j++){
                if(matrix[i][j] == 1 && i>0){
                    matrix[i][j] += matrix[i-1][j];
                }
                line[j] = matrix[i][j];
            }
            // line = matrix[i];
            // for(int k=0;k<line.length;k++){
            //     System.out.print(line[k]);
            // }
            // System.out.println();
            Arrays.sort(line);
            
//            ret = Math.max(ret,largestRectengleArea(line));
            for(int j=0;j<w;j++){
                ret = Math.max(ret,line[j]*(w-j));
            }
        }
        return ret;
    }

    /** 最大矩形面积 2 1 5 6 2 3 过程
    [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1],
     [0,1,1,0,1,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,1,1]]
    **/
    public int largestRectengleArea(int[] heights){
        int area = 0;
        int[] temp = new int[heights.length+2];//前后哨兵柱状图
        for(int i=0;i<heights.length;i++){
            temp[i+1] = heights[i];
        }
        Deque<Integer> stack = new ArrayDeque<>();
        stack.addLast(0);
        int len = temp.length;
        heights = temp;
        for(int i=1;i<len;i++){
            while(heights[stack.peekLast()] > heights[i]){
                int high = heights[stack.removeLast()];
                int with = i - stack.peekLast() -1;
                area = Math.max(area, high*with);
            }
            stack.addLast(i);
        }
        return area;
    }
}



class Solution2 {
    public int largestSubmatrix(int[][] matrix) {
        if(matrix == null || matrix.length == 0) return 0;
        // 列统计，遇0重新开始统计
        // 枚举行，行排序后计算最大矩形面积
        int ret = 0;
        int h = matrix.length;
        int w = matrix[0].length;
        int[] line = new int[matrix[0].length];
        for(int i=0;i<h;i++){
            for(int j=0;j<w;j++){
                if(matrix[i][j] == 1 && i>0){
                    matrix[i][j] += matrix[i-1][j];
                }
                line[j] = matrix[i][j];
            }
            Arrays.sort(line);
            for(int j=0;j<w;j++){
                /** 柱状图排序后，最大面积可以直接通过h*w 得到 即 2 1 5 6 2 3 -> 1 2 2 3 5 6 的柱状图最大面积**/
                ret = Math.max(ret,line[j]*(w-j)); 

            }
        }
        return ret;
    }
}


```

- [42.接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)
- [407.接雨水2](https://leetcode-cn.com/problems/trapping-rain-water-ii/)

