# 字节码执行
```
byte[] ----> 加载到JVM中成Class对象 --------> Reflect 执行 Class.main 方法
```
## 字节码加载Class成对象
同名class 文件,使用双亲委派机制加载，不会被重复加载
系统提供给我们应用程序类加载器是独一份的，如果通过这个类加载了我们的字节码，当客户端对源码进行了修改
再次提交运行时，应用程序类加载器会认为已经加载过了。
想要执行客户端提交的修改源码，不改变类名的情况下，我们需要支持热加载。

- **热加载**
    - 判断两个对象相等
        - 同一个.class 文件相同
        - 被同一个虚拟机加载
        - 被同一个类加载器加载
    - 跳过两个对象相等
        - 修改.class 来源的源码中的类名描述 
        - 每次使用新的类加载器加载
        
## Class类反射执行方法
```
Method mainMethod = clazz.getMethod("main", new Class[] { String[].class });
mainMethod.invoke(null, new String[] { systemIn });
```

## 限制客户端程序运行时间 Callable + Future
```
Callable<String> runTask = new Callable<String>() {
            @Override
            public String call() throws Exception {
                return JavaClassExecutor.execute(classBytes, systemIn);
            }
        };
        Future<String> res = null;
        try {
            res = pool.submit(runTask);
        } catch (RejectedExecutionException e) {
            return "WAIT_WARNING";
        }

        // 获取运行结果，处理非客户端代码错误
        String runResult;
        try {
            runResult = res.get(RUN_TIME_LIMITED, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            runResult = "Program interrupted.";
        } catch (ExecutionException e) {
            runResult = e.getCause().getMessage();
        } catch (TimeoutException e) {
            runResult = "Time Limit Exceeded.";
        } finally {
            res.cancel(true);
        }

```