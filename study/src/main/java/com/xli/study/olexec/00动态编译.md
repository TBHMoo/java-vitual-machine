# 动态编译
从jdk 1.6开始, 引入了动态编译API  JAVA Compiler API,实现了运行时将java代码，编译成字节码，然后加载进java 虚拟机
- **没有动态编译前** 
    - 编译过程
        - 先将源码写入 .java 文件，通过javac 编译这个文件，得到.class 文件，然后通过classLoader 加载进JVM
    - 缺点
        - 涉及.java文件和.class 文件生成和删除，和引入了IO操作，低效
- **有动态编译后**
    - 编译过程
        - 源码直接在内存中编译成 .class 文件相对的字节码，然后通过ClassLoader 加载进JVM
      

## 动态编译API 
- **JAVA Compiler API**
    - 从jdk 1.6开始引入 在tools.jar中
    - 调用demo
    ```
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        Boolean result = compiler.getTask(  null,
                                            javaFileManager,
                                            compileCollector,
                                            null,
                                            null, 
                                            sourceJavaFileObjectList).call();
    ```
    - 主要入参
        - `Writer out= null` 编译器的一个额外的输出 Writer，为 null 的话就是 System.err；
        - `JavaFileManager javaFileManager` 文件管理器,是.java 和.class 文件管理的抽象
        - `DiagnosticListener<? super JavaFileObject> diagnosticListener`; 诊断信息收集器(编译报错信息)；
        - `Iterable<String> options= null` 编译器的配置 javac 后面带的那些参数
        - `Iterable<String> classes= null`;需要被 annotation processing 处理的类的类名(不是很理解)
        - `Iterable<? extends JavaFileObject> compilationUnits ` 要被编译的单元们，就是一堆 JavaFileObject。
    - JAVAFileManager   摘自[http://pfmiles.github.io/blog/dynamic-java/](http://pfmiles.github.io/blog/dynamic-java/)
    ```
    JavaFileManager的意义
    一个广义的、管理“文件”资源的接口，并不一定指“操作系统的磁盘文件系统”
    其实JavaFileManager只是一个接口，只要行为正确，那么就无所谓“文件”到底以何种形式、实际被存放在哪里
    
    StandardJavaFileManager的默认行为
    这是基于磁盘文件的JavaFileManager实现, 所有的文件查找、新文件输出位置都在磁盘上完成；也就是说，如果直接使用默认的StandardJavaFileManager来做动态编译，那么得到的效果就跟命令行中直接使用javac编译差不多
    
    继承ForwardingJavaFileManager类，让compiler API脱离对文件系统的依赖
    如果想要将编译好的class文件放在内存中而不是磁盘上，那么需要使用一个ForwardingJavaFileManager来包装默认的StandardJavaFileManager并重写getJavaFileForOutput方法，将其实现改为内存操作；这个实现可参考上面的MemClsFileManager类
    不过ForwardingJavaFileManager还有许多别的方法，没有文档说明动态编译过程中到底那些方法会被调用,原则上讲，所有方法都有可能被调用
    但具体哪些方法被调用了可以被实测出来，这样可以有选择性地重写其中一些方法
    比如MemClsFileManager中，重写了inferBinaryName, list, close, getJavaFileForOutput方法，因为这些方法都会被“class文件放在内存中”这一策略所影响，所以需要兼容
    ```
    - MemJavaFileManager
    ```java
      
    ```
    - 编译过程
```
    sourceString --> JavaFileObject --> getCharContent -->  MemJavaFileManager.getJavaFileForOutput ------> fileObjectMap.put()  ---> openOutputStream -->getCompiledBytes 
    |-- 源码转成 javaFileObject 实现 getCharContent方法    |
                                                         | 实现getJavaFileForOutput用于接收，编译后的字节流数据-|                                                                                                          | 内存中准备用于接收编译后JavaFileObject,实现openOutputStream读取class字节流
```
## 实现动态编译
```java
public class StringSourceCompiler {

    private static Map<String, JavaFileObject> fileObjectMap = new ConcurrentHashMap<>();

    /** 使用 Pattern 预编译功能 */
    private static Pattern CLASS_PATTERN = Pattern.compile("class\\s+([$_a-zA-Z][$_a-zA-Z0-9]*)\\s*");

    /**
     *     sourceString --> JavaFileObject --> getCharContent -->  MemJavaFileManager.getJavaFileForOutput ------> fileObjectMap.put()  ---> openOutputStream -->getCompiledBytes
     *     |-- 源码转成 javaFileObject 实现 getCharContent方法    |
     *                                                          | 实现getJavaFileForOutput用于接收，编译后的字节流数据-|                                                                                                          | 内存中准备用于接收编译后JavaFileObject,实现openOutputStream读取class字节流
     *
     * > 首先，要得到源码才能进行编译，所以会调用 JavaFileObject 的 getCharContent 方法，得到源码的字符序 CharSequence；
     * > 然后，编译器会对得到的源码进行编译，得到字节码，并且会将得到的字节码封装进一个 JavaFileObject 对象；
     * > 编译器会把字节码结果存入一个 JavaFileObject 中，这个操作是需要创建一个 JavaFileObject 对象的，可是我们用来真实存储源码和字节码的 JavaFileObject 对象是我们自己写的，那么编译器如何得知它应该把编译生成的字节码放入一个怎样的 JavaFileObject 中呢?
     * > 这时就要轮到 JavaFileManager 出场了，编译器会调用我们传入的 JavaFileManager fileManager 的 getJavaFileForOutput 方法，这个方法会 new 一个我们写的 TmpJavaFileObject 对象，并把返回给编译器；
     * > 接下来，编译器会把生成的字节码放在 TmpJavaFileObject 对象中，存放的位置是由我们自己指定的，在 TmpJavaFileObject 中加入一个 ByteArrayOutputStream 属性用于存储字节码，编译器会通过 openOutputStream() 来创建输出流对象，并把这个用来存储字节的容器返回给编译器，让它把编译生成的字节码放进去；
     * > 最后，我们想要的是 byte[] 字节数组，而非一个输出流，只要再在 TmpJavaFileObject 中加入一个 getCompiledBytes() 方法将 ByteArrayOutputStream 中的内容变成 byte[] 返回即可
     *
     * /
     * @param source
     * @param compileCollector
     * @return
     */
    public static byte[] compile(String source, DiagnosticCollector<JavaFileObject> compileCollector){

        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        //编译器的一个额外的输出 Writer，为 null 的话就是 System.err；
        Writer out= null;
        JavaFileManager javaFileManager = new MemJavaFileManager(compiler.getStandardFileManager(compileCollector,null,null));
        //诊断信息收集器；
        DiagnosticListener<? super JavaFileObject> diagnosticListener= null;
        //编译器的配置；
        Iterable<String> options= null;
        //需要被 annotation processing 处理的类的类名；
        Iterable<String> classes= null;
        //要被编译的单元们，就是一堆 JavaFileObject。
        Iterable<? extends JavaFileObject> compilationUnits= new ArrayList<>();
        ArrayList<JavaFileObject> sourceJavaFileObjectList = new ArrayList();

        Matcher matcher = CLASS_PATTERN.matcher(source);
        String className;
        if (matcher.find()) {
            className = matcher.group(1);
        } else {
            throw new IllegalArgumentException("No valid class");
        }

        // 把源码字符串构造成JavaFileObject，供编译使用
        TmpJavaFileObject sourceJavaFileObject = new TmpJavaFileObject(className,source);
        sourceJavaFileObjectList.add(sourceJavaFileObject);

        Boolean result = compiler.getTask(null,javaFileManager,compileCollector,null,null, sourceJavaFileObjectList).call();
        JavaFileObject javaFileObject = fileObjectMap.get(className);
        if (result && javaFileObject!=null){
            return ((TmpJavaFileObject)javaFileObject).getCompiledBytes();
        }
        return null;
    }


    /**
     * getCharContent
     * getJavaFileForOutput
     * */
    public static class MemJavaFileManager extends ForwardingJavaFileManager<JavaFileManager>{


        /**
         * Creates a new instance of ForwardingJavaFileManager.
         *
         * @param fileManager delegate to this file manager
         */
        protected MemJavaFileManager(JavaFileManager fileManager){
            super(fileManager);
        }

        @Override
        public JavaFileObject getJavaFileForInput(Location location,String className,JavaFileObject.Kind kind) throws IOException{
            JavaFileObject inputJavaFileObjet = fileObjectMap.get(className);
            if (null == inputJavaFileObjet){
                return super.getJavaFileForInput(location,className,kind);
            }
            return inputJavaFileObjet;
        }

        /**
         * 构造用来存储字节码的JavaFileObject
         * 需要传入kind，即我们想要构建一个存储什么类型文件的JavaFileObject
         */
        @Override
        public JavaFileObject getJavaFileForOutput(Location location,String className,JavaFileObject.Kind kind,FileObject sibling) throws IOException{
            JavaFileObject classJavaFileObject = new TmpJavaFileObject(className,kind);
            fileObjectMap.put(className,classJavaFileObject);
            return classJavaFileObject;
        }
    }

    public static class TmpJavaFileObject extends SimpleJavaFileObject {

        private String source;

        private ByteArrayOutputStream outputStream;
        /**
         * 构造用来存储源代码的JavaFileObject
         * 需要传入源码source，然后调用父类的构造方法创建kind = Kind.SOURCE的JavaFileObject对象
         */
        public TmpJavaFileObject(String name,String source){
            super(URI.create("String:///" + name + Kind.SOURCE.extension), Kind.SOURCE);
            this.source = source;
        }

        /**
         * 构造用来存储字节码的JavaFileObject
         * 需要传入kind，即我们想要构建一个存储什么类型文件的JavaFileObject
         */
        public TmpJavaFileObject(String name, Kind kind) {
            super(URI.create("String:///" + name + Kind.SOURCE.extension), kind);
            this.source = null;
        }


        @Override
        public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException{
            if(null == source){
                throw new IllegalArgumentException("source == null");
            }
            return source;
        }

        @Override
        public OutputStream openOutputStream() throws IOException {
            outputStream = new ByteArrayOutputStream();
            return outputStream;
        }

        public byte[] getCompiledBytes(){
            return outputStream.toByteArray();
        }
    }
}

```